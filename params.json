{
  "name": "Jsonapi spec helpers",
  "tagline": "",
  "body": "# jsonapi_spec_helpers\r\n\r\nThis gem provides a number of low-level helpers as well as an abstraction for asserting entire payloads.\r\n\r\n## Low-level helpers\r\n\r\n* `json`: Parsed JSON from the response represented as a ruby hash.\r\n* `json_item`: Typically used for `show` actions, this grabs the relevant attributes from the response and merges with `id` and `type`. `type` is renamed `jsonapi_type` so it does not conflict with a `type` attribute.\r\n* `json_items`: Like `json_item` but for `index` actions. Pass indices to grab specific items, e.g. `json_items(0,1)`.\r\n* `json_related_link`: Assert the payload has a `link` for the given relation, e.g. `expect(json_related_link(json_item, 'people').to eq('/people/1')`\r\n* `json_included_types`: A unique array of all `type`s in the `included` response.\r\n* `json_includes(type, *indicies)`: Grab from `included` and transform into a `json_item`, e.g. `json_includes('people')`.\r\n* `json_include(type, index = 0)`: Same as `json_includes` but returns a single element instead of an array.\r\n* `json_ids`: An array of all ids in `json_items`. Pass `json_ids(true)` to return all integers.\r\n\r\n## assert_payload\r\n\r\nIn JSONAPI responses, the same object payload can be repeated across many different responses. So, instead of asserting on the response itself, you can assert the response contains a given payload. Start by defining your payloads:\r\n\r\n```ruby\r\nJsonapiSpecHelpers::Payload.register(:person) do\r\n  key(:name)\r\n  key(:age)\r\nend\r\n```\r\n\r\nAnd then assert on them in specs:\r\n\r\n```ruby\r\nperson = Person.last\r\n# Pass:\r\n# * registered payload name\r\n# * a record to compare against\r\n# * a json_item\r\nassert_payload(:person, person, json_include('people'))\r\n```\r\n\r\nThis asserts:\r\n\r\n* All registered keys have correct values (compared to given record)\r\n* No registered keys are missing\r\n* No extra keys are present in the response\r\n\r\nIt's the rough code equivalent of:\r\n\r\n```ruby\r\nperson = Person.last\r\njson = JSON.parse(response.body)\r\nincluded = json['included'].find { |incl| incl['type'] == 'people' }\r\nexpect(included).to have_key('name')\r\nexpect(included['name']).to eq(person.name)\r\nexpect(included).to have_key('age')\r\nexpect(included['age']).to eq(person.age)\r\nexpect(included.keys).to match_array(%w(name age))\r\n```\r\n\r\n### Custom Payloads\r\n\r\nLet's say your serializer always capitalizes `name`. In this case, the above `assert_record_payload` would fail. To make it pass, supply a block to the `key` argument:\r\n\r\n```ruby\r\nJsonapiSpecHelpers::Payload.register(:person) do\r\n  key(:name) { |record| record.name.upcase }\r\n  key(:age)\r\nend\r\n```\r\n\r\nThe test will now pass, as we've registered a custom response comparison.\r\n\r\nYou can customize payloads at assertion-time as well. Let's say you only want to render `age` if the current user is an admin. A spec could look something like:\r\n\r\n```ruby\r\nsign_in(:admin)\r\nget :show, id: person.id\r\nassert_payload(:person, person, json_item)\r\nsign_in(:non_admin)\r\nget :show, id: person.id\r\nassert_payload(:person, person, json_item) do\r\n  no_key(:age)\r\nend\r\n```\r\n\r\nThe `no_key` method overrides the default `age` key and specifies this key should not be present in the response. Any keys specified in this block will override the defaults.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}